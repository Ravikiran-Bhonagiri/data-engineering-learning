# Day 00: The "Why" (Understanding the Problem)

**Goal:** Understand why dbt exists and the problems it solves.

---

## Before dbt: Your Current Pain Points

You're a SQL expert, but your workflow probably looks like this:

### Scenario: Building a Customer Dimension Table

```sql
-- Step 1: Run clean_customers.sql first (manually)
CREATE TABLE analytics.clean_customers AS
SELECT 
    id,
    LOWER(email) AS email,
    first_name,
    last_name
FROM raw.customers
WHERE email IS NOT NULL;

-- Step 2: Run customer_orders.sql second (manually, after Step 1)
CREATE TABLE analytics.customer_orders AS
SELECT 
    customer_id,
    COUNT(*) AS total_orders,
    SUM(amount) AS lifetime_value
FROM raw.orders
GROUP BY 1;

-- Step 3: Run dim_customers.sql last (manually, after Steps 1 & 2)
CREATE TABLE analytics.dim_customers AS
SELECT
    c.id AS customer_id,
    c.first_name || ' ' || c.last_name AS full_name,
    c.email,
    COALESCE(o.total_orders, 0) AS total_orders,
    COALESCE(o.lifetime_value, 0) AS lifetime_value
FROM analytics.clean_customers c
LEFT JOIN analytics.customer_orders o ON c.id = o.customer_id;
```

### Problems

- ❌ Must run in order or everything breaks
- ❌ Hard-coded table names everywhere
- ❌ No tests (is customer_id unique? who knows!)
- ❌ No documentation
- ❌ Change `clean_customers`? Good luck finding all dependencies

---

## With dbt: Automatic Everything

Same logic, dbt style:

**File:** `models/staging/stg_customers.sql`
```sql
SELECT 
    id AS customer_id,
    LOWER(email) AS email,
    first_name,
    last_name
FROM {{ source('raw', 'customers') }}
WHERE email IS NOT NULL
```

**File:** `models/staging/stg_orders.sql`
```sql
SELECT 
    customer_id,
    COUNT(*) AS total_orders,
    SUM(amount) AS lifetime_value
FROM {{ source('raw', 'orders') }}
GROUP BY 1
```

**File:** `models/marts/dim_customers.sql`
```sql
SELECT
    c.customer_id,
    c.first_name || ' ' || c.last_name AS full_name,
    c.email,
    COALESCE(o.total_orders, 0) AS total_orders,
    COALESCE(o.lifetime_value, 0) AS lifetime_value
FROM {{ ref('stg_customers') }} c
LEFT JOIN {{ ref('stg_orders') }} o ON c.customer_id = o.customer_id
```

**File:** `models/schema.yml`
```yaml
models:
  - name: dim_customers
    columns:
      - name: customer_id
        tests:
          - unique
          - not_null
```

### Run It

```bash
dbt run   # Runs in correct order automatically!
dbt test  # Tests customer_id is unique and not null
```

### Benefits

- ✅ `ref()` tracks dependencies - runs in correct order
- ✅ Tests built-in
- ✅ Documentation from YAML
- ✅ Change `stg_customers`? dbt knows what depends on it

---

## The "Aha!" Moment

**Traditional SQL workflow:**
1. Write 3 separate SQL scripts
2. Remember to run in order: 1→2→3
3. Hard-code table names
4. Manually test (maybe)
5. Hope nothing breaks

**dbt workflow:**
1. Write 3 `.sql` models
2. Run `dbt run` (order handled automatically)
3. Use `ref()` and `source()` (tracked automatically)
4. Tests run with `dbt test`
5. Documentation with `dbt docs generate`

---

**✅ Day 0 Complete:** You understand why dbt exists.  
**Next:** `02_Day_01.md` (Setup & First Project) →
