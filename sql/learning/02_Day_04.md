# üóìÔ∏è Day 4: Joins Deep Dive

## üìö Topics Covered
- INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN
- Self-joins for hierarchies
- CROSS JOIN
- Multiple table joins
- ON vs WHERE clause

---

## üéØ Problem 1: Employee Department List
**Difficulty: Easy** | **Concept: INNER JOIN**

List employees with their department names.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    e.name AS employee,
    d.name AS department
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
ORDER BY d.name, e.name;
```
</details>

---

## üéØ Problem 2: All Customers with Orders (Optional)
**Difficulty: Easy** | **Concept: LEFT JOIN**

List all customers, showing their order count (0 if none).

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    c.name AS customer,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.amount), 0) AS total_spent
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.id, c.name
ORDER BY total_spent DESC;
```

**Note:** LEFT JOIN keeps all customers, even those without orders.
</details>

---

## üéØ Problem 3: Customers Without Orders
**Difficulty: Easy** | **Concept: LEFT JOIN + NULL check**

Find customers who have never placed an order.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT c.name, c.email, c.city
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE o.id IS NULL;
```

**Alternative using NOT EXISTS:**
```sql
SELECT c.name, c.email, c.city
FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.id
);
```
</details>

---

## üéØ Problem 4: Employee Manager Pairs
**Difficulty: Medium** | **Concept: Self-join**

Show each employee with their manager's name.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    e.name AS employee,
    e.salary,
    COALESCE(m.name, 'No Manager') AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id
ORDER BY m.name NULLS FIRST, e.name;
```
</details>

---

## üéØ Problem 5: Employee Earns More Than Manager
**Difficulty: Medium** | **Concept: Self-join with condition**

Find employees who earn more than their manager.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    e.name AS employee,
    e.salary AS employee_salary,
    m.name AS manager,
    m.salary AS manager_salary
FROM employees e
JOIN employees m ON e.manager_id = m.id
WHERE e.salary > m.salary;
```
</details>

---

## üéØ Problem 6: Order Details Full View
**Difficulty: Medium** | **Concept: Multiple joins**

Show order with customer name, product name, quantity, total.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    o.id AS order_id,
    c.name AS customer,
    p.name AS product,
    oi.quantity,
    oi.unit_price,
    oi.quantity * oi.unit_price AS line_total
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
ORDER BY o.id, p.name;
```
</details>

---

## üéØ Problem 7: Department Employee Summary
**Difficulty: Medium** | **Concept: LEFT JOIN with aggregation**

Show ALL departments with employee count (including empty ones).

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    d.name AS department,
    d.location,
    COUNT(e.id) AS employee_count,
    COALESCE(ROUND(AVG(e.salary), 2), 0) AS avg_salary
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name, d.location
ORDER BY employee_count DESC;
```
</details>

---

## üéØ Problem 8: Cross Join Example
**Difficulty: Easy** | **Concept: CROSS JOIN**

Create all possible combinations of departments and products (Cartesian product).

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    d.name AS department,
    p.name AS product,
    p.price
FROM departments d
CROSS JOIN products p
WHERE p.category = 'Furniture'
ORDER BY d.name, p.name;
```

**Use case:** Generate all possible combinations of dimensions for a calendar/matrix.
</details>

---

## üéØ Problem 9: Products Not in Any Order
**Difficulty: Easy** | **Concept: LEFT JOIN + NULL**

Find products that have never been ordered.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT p.name, p.category, p.price
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE oi.id IS NULL;
```
</details>

---

## üéØ Problem 10: Colleagues in Same Department
**Difficulty: Medium** | **Concept: Self-join on department**

List pairs of employees who work in the same department.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    e1.name AS employee1,
    e2.name AS employee2,
    d.name AS department
FROM employees e1
JOIN employees e2 ON e1.department_id = e2.department_id
JOIN departments d ON e1.department_id = d.id
WHERE e1.id < e2.id  -- Avoid duplicates and self-pairs
ORDER BY d.name, e1.name;
```
</details>

---

## üéØ Problem 11: Orders with Product Count
**Difficulty: Medium** | **Concept: JOIN + GROUP BY**

For each order, show distinct product count and total quantity.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    o.id AS order_id,
    c.name AS customer,
    o.order_date,
    COUNT(DISTINCT oi.product_id) AS product_types,
    SUM(oi.quantity) AS total_items,
    o.amount
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, c.name, o.order_date, o.amount
ORDER BY o.order_date;
```
</details>

---

## üéØ Problem 12: Top Customer by City
**Difficulty: Hard** | **Concept: JOIN + subquery**

Find the customer with most orders in each city.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH customer_orders AS (
    SELECT 
        c.id,
        c.name,
        c.city,
        COUNT(o.id) AS order_count
    FROM customers c
    LEFT JOIN orders o ON c.id = o.customer_id
    GROUP BY c.id, c.name, c.city
),
ranked AS (
    SELECT *,
        RANK() OVER (PARTITION BY city ORDER BY order_count DESC) AS rn
    FROM customer_orders
)
SELECT name, city, order_count
FROM ranked
WHERE rn = 1;
```
</details>

---

## üéØ Problem 13: ON vs WHERE Clause
**Difficulty: Medium** | **Concept: Filter placement**

Show the difference between ON and WHERE in LEFT JOIN.

```sql
-- Compare these two queries
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- Query 1: Filter in ON clause (preserves all customers)
SELECT c.name, o.id, o.amount, o.status
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id 
    AND o.status = 'completed';

-- Query 2: Filter in WHERE clause (removes non-matching customers)
SELECT c.name, o.id, o.amount, o.status
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE o.status = 'completed' OR o.id IS NULL;
```

**Key insight:** 
- ON filter: Applied during join, NULLs preserved for left table
- WHERE filter: Applied after join, can remove left table rows
</details>

---

## üéØ Problem 14: Multiple Join Conditions
**Difficulty: Medium** | **Concept: Complex join**

Find orders where the order amount matches sum of order items.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    o.id,
    o.amount AS recorded_amount,
    SUM(oi.quantity * oi.unit_price) AS calculated_amount,
    CASE 
        WHEN o.amount = SUM(oi.quantity * oi.unit_price) THEN 'Match'
        ELSE 'Mismatch'
    END AS status
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.amount;
```
</details>

---

## üéØ Problem 15: Full Employee Hierarchy
**Difficulty: Hard** | **Concept: Self-join chain**

Show employee ‚Üí manager ‚Üí top manager chain.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    e.name AS employee,
    m1.name AS direct_manager,
    COALESCE(m2.name, m1.name) AS top_manager
FROM employees e
LEFT JOIN employees m1 ON e.manager_id = m1.id
LEFT JOIN employees m2 ON m1.manager_id = m2.id
ORDER BY top_manager NULLS FIRST, direct_manager NULLS FIRST, e.name;
```

**Note:** For deeper hierarchies, use recursive CTEs (Day 7).
</details>

---

## üìù Day 4 Interview Questions

1. **What's the difference between INNER and LEFT JOIN?**
   - INNER: Only matching rows from both tables
   - LEFT: All rows from left table + matching from right

2. **When would you use a self-join?**
   - Hierarchies (employee-manager)
   - Finding pairs within same table
   - Comparing rows in same table

3. **What is a Cartesian product?**
   - Result of CROSS JOIN
   - Every row from table A paired with every row from table B
   - Use case: Generating calendars, all combinations

4. **ON vs WHERE for JOIN conditions?**
   - ON: Applied during join creation
   - WHERE: Applied after join completion
   - Matters especially for OUTER JOINs

5. **How to optimize multi-table joins?**
   - Start with smallest result set
   - Use indexes on join columns
   - Filter early (in WHERE or subquery)

---

## ‚úÖ Day 4 Checklist

- [ ] Completed all 15 problems
- [ ] Understand INNER vs LEFT vs FULL JOIN
- [ ] Can write self-joins for hierarchies
- [ ] Know difference between ON and WHERE
- [ ] Comfortable with 3+ table joins
