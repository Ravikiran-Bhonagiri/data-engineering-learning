# üóìÔ∏è Day 8: Stored Procedures & Triggers

## üìö Topics Covered
- Stored procedure basics
- Functions (scalar & table-valued)
- Triggers (BEFORE/AFTER)
- Audit logging

---

## üéØ Problem 1: Simple Stored Procedure
**Difficulty: Medium** | **Concept: Procedure basics**

Create a procedure to add a new customer.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
CREATE OR REPLACE PROCEDURE add_customer(
    p_name VARCHAR(100),
    p_email VARCHAR(100),
    p_city VARCHAR(100)
)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO customers (name, email, city)
    VALUES (p_name, p_email, p_city);
    
    RAISE NOTICE 'Customer % added successfully', p_name;
END;
$$;

-- Call the procedure
CALL add_customer('New Company', 'info@newcompany.com', 'Miami');
```
</details>

---

## üéØ Problem 2: Function with Return Value
**Difficulty: Medium** | **Concept: Scalar function**

Create a function to calculate annual bonus (10% of salary).

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
CREATE OR REPLACE FUNCTION calculate_bonus(emp_id INT)
RETURNS DECIMAL(10,2)
LANGUAGE plpgsql
AS $$
DECLARE
    emp_salary DECIMAL(10,2);
BEGIN
    SELECT salary INTO emp_salary
    FROM employees
    WHERE id = emp_id;
    
    RETURN emp_salary * 0.10;
END;
$$;

-- Use the function
SELECT name, salary, calculate_bonus(id) AS bonus
FROM employees;
```
</details>

---

## üéØ Problem 3: Table-Valued Function
**Difficulty: Medium** | **Concept: Return table**

Create function returning employees in a department.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
CREATE OR REPLACE FUNCTION get_dept_employees(dept_id INT)
RETURNS TABLE (
    emp_name VARCHAR(100),
    emp_salary DECIMAL(10,2),
    emp_hire_date DATE
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT name, salary, hire_date
    FROM employees
    WHERE department_id = dept_id
    ORDER BY salary DESC;
END;
$$;

-- Use the function
SELECT * FROM get_dept_employees(1);
```
</details>

---

## üéØ Problem 4: Audit Trigger
**Difficulty: Hard** | **Concept: BEFORE UPDATE trigger**

Create a trigger to log salary changes.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- First, create audit table
CREATE TABLE salary_audit (
    id SERIAL PRIMARY KEY,
    employee_id INT,
    old_salary DECIMAL(10,2),
    new_salary DECIMAL(10,2),
    changed_at TIMESTAMP DEFAULT NOW(),
    changed_by VARCHAR(100) DEFAULT CURRENT_USER
);

-- Create trigger function
CREATE OR REPLACE FUNCTION log_salary_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF OLD.salary <> NEW.salary THEN
        INSERT INTO salary_audit (employee_id, old_salary, new_salary)
        VALUES (OLD.id, OLD.salary, NEW.salary);
    END IF;
    RETURN NEW;
END;
$$;

-- Create trigger
CREATE TRIGGER salary_change_trigger
BEFORE UPDATE ON employees
FOR EACH ROW
EXECUTE FUNCTION log_salary_change();

-- Test it
UPDATE employees SET salary = salary * 1.05 WHERE id = 1;
SELECT * FROM salary_audit;
```
</details>

---

## üéØ Problem 5: Prevent Negative Salary
**Difficulty: Medium** | **Concept: Validation trigger**

Create trigger to prevent salary going below minimum.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
CREATE OR REPLACE FUNCTION check_minimum_salary()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF NEW.salary < 30000 THEN
        RAISE EXCEPTION 'Salary cannot be below $30,000';
    END IF;
    RETURN NEW;
END;
$$;

CREATE TRIGGER enforce_min_salary
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
EXECUTE FUNCTION check_minimum_salary();

-- Test: This will fail
UPDATE employees SET salary = 25000 WHERE id = 12;
```
</details>

---

## üéØ Problem 6: Archive on Delete
**Difficulty: Hard** | **Concept: BEFORE DELETE trigger**

Log deleted orders before removal.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- Create archive table
CREATE TABLE orders_archive (
    id INT,
    customer_id INT,
    order_date DATE,
    amount DECIMAL(10,2),
    status VARCHAR(20),
    deleted_at TIMESTAMP DEFAULT NOW()
);

-- Create trigger function
CREATE OR REPLACE FUNCTION archive_deleted_order()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO orders_archive (id, customer_id, order_date, amount, status)
    VALUES (OLD.id, OLD.customer_id, OLD.order_date, OLD.amount, OLD.status);
    RETURN OLD;
END;
$$;

-- Create trigger
CREATE TRIGGER archive_order_before_delete
BEFORE DELETE ON orders
FOR EACH ROW
EXECUTE FUNCTION archive_deleted_order();
```
</details>

---

## üìù Day 8 Interview Questions

1. **Stored Procedure vs Function?**
   - Procedure: Can modify data, no return required
   - Function: Returns value, should avoid side effects

2. **BEFORE vs AFTER trigger?**
   - BEFORE: Can modify NEW values, runs before action
   - AFTER: For logging, runs after action completes

3. **Can a trigger call another trigger?**
   - Yes, cascading triggers possible
   - Risk of infinite loops

---

## ‚úÖ Day 8 Checklist

- [ ] Completed all 6 problems
- [ ] Know procedure vs function difference
- [ ] Can create BEFORE/AFTER triggers
- [ ] Understand audit logging pattern
