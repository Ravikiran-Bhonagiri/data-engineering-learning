# üóìÔ∏è Day 5: Subqueries & CTEs

## üìö Topics Covered
- Scalar subqueries
- Correlated vs non-correlated subqueries
- EXISTS vs IN
- Common Table Expressions (CTEs)
- UNION, INTERSECT, EXCEPT

---

## üéØ Problem 1: Above Average Salary
**Difficulty: Easy** | **Concept: Scalar subquery**

Find employees earning more than the company average.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees)
ORDER BY salary DESC;
```
</details>

---

## üéØ Problem 2: Above Department Average
**Difficulty: Medium** | **Concept: Correlated subquery**

Find employees earning more than their department average.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT e.name, e.salary, e.department_id
FROM employees e
WHERE e.salary > (
    SELECT AVG(salary) 
    FROM employees 
    WHERE department_id = e.department_id
)
ORDER BY e.department_id, e.salary DESC;
```

**Key:** The inner query references `e.department_id` from the outer query (correlated).
</details>

---

## üéØ Problem 3: Second Highest Salary
**Difficulty: Medium** | **Concept: Subquery with LIMIT**

Find the second highest salary in the company.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- Method 1: Using OFFSET
SELECT salary FROM employees
ORDER BY salary DESC
LIMIT 1 OFFSET 1;

-- Method 2: Using subquery
SELECT MAX(salary) AS second_highest
FROM employees
WHERE salary < (SELECT MAX(salary) FROM employees);

-- Method 3: Using DENSE_RANK (handles ties)
SELECT salary FROM (
    SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) as rn
    FROM employees
) ranked
WHERE rn = 2;
```
</details>

---

## üéØ Problem 4: EXISTS vs IN
**Difficulty: Medium** | **Concept: EXISTS pattern**

Find customers who have placed at least one order.

```sql
-- Write both EXISTS and IN versions
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- Using IN
SELECT name, email
FROM customers
WHERE id IN (SELECT customer_id FROM orders);

-- Using EXISTS (often faster for large tables)
SELECT name, email
FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.id
);
```

**When to use EXISTS vs IN:**
- EXISTS: Better when subquery returns many rows
- IN: Better when subquery returns few distinct values
</details>

---

## üéØ Problem 5: NOT EXISTS Pattern
**Difficulty: Easy** | **Concept: NOT EXISTS**

Find customers who have never ordered.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT name, email, city
FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.id
);
```
</details>

---

## üéØ Problem 6: Simple CTE
**Difficulty: Easy** | **Concept: CTE basics**

Use a CTE to find departments with above-average employee count.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH dept_counts AS (
    SELECT 
        department_id,
        COUNT(*) AS emp_count
    FROM employees
    GROUP BY department_id
)
SELECT 
    d.name,
    dc.emp_count
FROM dept_counts dc
JOIN departments d ON dc.department_id = d.id
WHERE emp_count > (SELECT AVG(emp_count) FROM dept_counts);
```
</details>

---

## üéØ Problem 7: Multiple CTEs
**Difficulty: Medium** | **Concept: Chained CTEs**

Calculate customer tier based on total spending.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH customer_totals AS (
    SELECT 
        customer_id,
        SUM(amount) AS total_spent
    FROM orders
    GROUP BY customer_id
),
customer_tiers AS (
    SELECT 
        customer_id,
        total_spent,
        CASE 
            WHEN total_spent >= 3000 THEN 'Gold'
            WHEN total_spent >= 1500 THEN 'Silver'
            ELSE 'Bronze'
        END AS tier
    FROM customer_totals
)
SELECT 
    c.name,
    ct.total_spent,
    ct.tier
FROM customer_tiers ct
JOIN customers c ON ct.customer_id = c.id
ORDER BY ct.total_spent DESC;
```
</details>

---

## üéØ Problem 8: Subquery in SELECT
**Difficulty: Medium** | **Concept: Scalar subquery in SELECT**

Show each employee with their department's total headcount.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    e.name,
    e.department_id,
    (SELECT COUNT(*) 
     FROM employees e2 
     WHERE e2.department_id = e.department_id) AS dept_size
FROM employees e
ORDER BY dept_size DESC, e.name;
```
</details>

---

## üéØ Problem 9: UNION to Combine Results
**Difficulty: Easy** | **Concept: UNION**

Combine employees and customers into one contact list.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT name, email, 'Employee' AS type
FROM employees
UNION
SELECT name, email, 'Customer' AS type
FROM customers
ORDER BY type, name;
```

**Note:** UNION removes duplicates. Use UNION ALL to keep all rows.
</details>

---

## üéØ Problem 10: Department with Most Employees
**Difficulty: Medium** | **Concept: Subquery with aggregation**

Find the department(s) with the most employees.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH dept_counts AS (
    SELECT 
        d.name AS department,
        COUNT(e.id) AS emp_count
    FROM departments d
    LEFT JOIN employees e ON d.id = e.department_id
    GROUP BY d.id, d.name
)
SELECT department, emp_count
FROM dept_counts
WHERE emp_count = (SELECT MAX(emp_count) FROM dept_counts);
```
</details>

---

## üéØ Problem 11: All vs ANY
**Difficulty: Medium** | **Concept: ALL/ANY operators**

Find employees who earn more than ALL employees in Marketing.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT name, salary
FROM employees
WHERE salary > ALL (
    SELECT salary 
    FROM employees 
    WHERE department_id = 3  -- Marketing
)
ORDER BY salary DESC;
```
</details>

---

## üéØ Problem 12: Top N per Group
**Difficulty: Hard** | **Concept: Correlated subquery**

Find top 2 earners in each department.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- Using CTE with window function
WITH ranked AS (
    SELECT 
        e.name,
        e.salary,
        d.name AS department,
        DENSE_RANK() OVER (
            PARTITION BY e.department_id 
            ORDER BY e.salary DESC
        ) AS rn
    FROM employees e
    JOIN departments d ON e.department_id = d.id
)
SELECT department, name, salary
FROM ranked
WHERE rn <= 2
ORDER BY department, salary DESC;
```
</details>

---

## üéØ Problem 13: Running Comparison (without window)
**Difficulty: Hard** | **Concept: Self-referencing subquery**

Find orders larger than the customer's previous order.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    o.id,
    c.name AS customer,
    o.order_date,
    o.amount,
    (SELECT MAX(o2.amount) 
     FROM orders o2 
     WHERE o2.customer_id = o.customer_id 
       AND o2.order_date < o.order_date) AS prev_max
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.amount > COALESCE((
    SELECT MAX(o2.amount) 
    FROM orders o2 
    WHERE o2.customer_id = o.customer_id 
      AND o2.order_date < o.order_date
), 0)
ORDER BY c.name, o.order_date;
```
</details>

---

## üéØ Problem 14: Derived Table
**Difficulty: Medium** | **Concept: Subquery in FROM**

Show average order amount per customer tier.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    customer_tier.tier,
    COUNT(*) AS customer_count,
    ROUND(AVG(customer_tier.total_spent), 2) AS avg_spent
FROM (
    SELECT 
        c.id,
        c.name,
        COALESCE(SUM(o.amount), 0) AS total_spent,
        CASE 
            WHEN COALESCE(SUM(o.amount), 0) >= 3000 THEN 'Gold'
            WHEN COALESCE(SUM(o.amount), 0) >= 1500 THEN 'Silver'
            ELSE 'Bronze'
        END AS tier
    FROM customers c
    LEFT JOIN orders o ON c.id = o.customer_id
    GROUP BY c.id, c.name
) AS customer_tier
GROUP BY customer_tier.tier
ORDER BY avg_spent DESC;
```
</details>

---

## üéØ Problem 15: CTE for Readability
**Difficulty: Medium** | **Concept: Refactoring with CTE**

Refactor this complex query using CTEs for better readability.

```sql
-- Original messy query
SELECT c.name, 
       (SELECT SUM(amount) FROM orders WHERE customer_id = c.id),
       (SELECT COUNT(*) FROM orders WHERE customer_id = c.id)
FROM customers c
WHERE c.id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 1);
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH customer_orders AS (
    SELECT 
        customer_id,
        COUNT(*) AS order_count,
        SUM(amount) AS total_amount
    FROM orders
    GROUP BY customer_id
),
repeat_customers AS (
    SELECT customer_id, order_count, total_amount
    FROM customer_orders
    WHERE order_count > 1
)
SELECT 
    c.name,
    rc.total_amount,
    rc.order_count
FROM repeat_customers rc
JOIN customers c ON rc.customer_id = c.id
ORDER BY rc.total_amount DESC;
```
</details>

---

## üìù Day 5 Interview Questions

1. **Correlated vs Non-correlated subquery?**
   - Non-correlated: Runs once, independent of outer query
   - Correlated: Runs for each row of outer query, references outer

2. **When to use EXISTS vs IN?**
   - EXISTS: Large subquery results, checking existence
   - IN: Small, distinct value lists

3. **What is a CTE?**
   - Common Table Expression
   - Named temporary result set within a query
   - Improves readability, can be recursive

4. **Can a CTE be referenced multiple times?**
   - Yes, that's a main advantage over subqueries
   - Optimizer may materialize or inline

5. **UNION vs UNION ALL?**
   - UNION: Removes duplicates (slower)
   - UNION ALL: Keeps all rows (faster)

---

## ‚úÖ Day 5 Checklist

- [ ] Completed all 15 problems
- [ ] Understand correlated vs non-correlated
- [ ] Know when to use EXISTS vs IN
- [ ] Can write and chain CTEs
- [ ] Comfortable with UNION/INTERSECT/EXCEPT
