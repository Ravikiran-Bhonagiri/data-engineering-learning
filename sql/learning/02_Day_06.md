# üóìÔ∏è Day 6: Window Functions

## üìö Topics Covered
- ROW_NUMBER, RANK, DENSE_RANK
- Running totals with SUM OVER
- LAG and LEAD for row comparisons
- FIRST_VALUE, LAST_VALUE
- Moving averages

---

## üéØ Problem 1: Basic Row Number
**Difficulty: Easy** | **Concept: ROW_NUMBER**

Assign row numbers to employees ordered by salary.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num,
    name,
    salary
FROM employees;
```
</details>

---

## üéØ Problem 2: Rank vs Dense Rank
**Difficulty: Easy** | **Concept: Understanding ranking differences**

Show the difference between ROW_NUMBER, RANK, and DENSE_RANK.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num,
    RANK() OVER (ORDER BY salary DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS dense_rank
FROM employees;
```

**Key differences:**
- ROW_NUMBER: Always unique (1, 2, 3, 4, 5...)
- RANK: Ties get same rank, then skip (1, 2, 2, 4, 5...)
- DENSE_RANK: Ties get same rank, no skip (1, 2, 2, 3, 4...)
</details>

---

## üéØ Problem 3: Rank Within Department
**Difficulty: Medium** | **Concept: PARTITION BY**

Rank employees by salary within each department.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    d.name AS department,
    e.name AS employee,
    e.salary,
    DENSE_RANK() OVER (
        PARTITION BY e.department_id 
        ORDER BY e.salary DESC
    ) AS dept_rank
FROM employees e
JOIN departments d ON e.department_id = d.id
ORDER BY d.name, dept_rank;
```
</details>

---

## üéØ Problem 4: Top Earner per Department
**Difficulty: Medium** | **Concept: Filter with window function**

Find the highest paid employee in each department.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH ranked AS (
    SELECT 
        e.name,
        e.salary,
        d.name AS department,
        RANK() OVER (
            PARTITION BY e.department_id 
            ORDER BY e.salary DESC
        ) AS rn
    FROM employees e
    JOIN departments d ON e.department_id = d.id
)
SELECT department, name, salary
FROM ranked
WHERE rn = 1
ORDER BY salary DESC;
```
</details>

---

## üéØ Problem 5: Running Total
**Difficulty: Medium** | **Concept: SUM OVER**

Calculate running total of order amounts by date.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) AS running_total
FROM orders
ORDER BY order_date;
```
</details>

---

## üéØ Problem 6: Running Total per Customer
**Difficulty: Medium** | **Concept: PARTITION + running total**

Calculate running total of orders per customer.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    c.name AS customer,
    o.order_date,
    o.amount,
    SUM(o.amount) OVER (
        PARTITION BY o.customer_id 
        ORDER BY o.order_date
        ROWS UNBOUNDED PRECEDING
    ) AS customer_running_total
FROM orders o
JOIN customers c ON o.customer_id = c.id
ORDER BY c.name, o.order_date;
```
</details>

---

## üéØ Problem 7: Compare to Previous Row (LAG)
**Difficulty: Medium** | **Concept: LAG function**

Show each order with the previous order's amount.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    c.name AS customer,
    o.order_date,
    o.amount,
    LAG(o.amount) OVER (
        PARTITION BY o.customer_id 
        ORDER BY o.order_date
    ) AS prev_amount,
    o.amount - COALESCE(LAG(o.amount) OVER (
        PARTITION BY o.customer_id 
        ORDER BY o.order_date
    ), 0) AS difference
FROM orders o
JOIN customers c ON o.customer_id = c.id
ORDER BY c.name, o.order_date;
```
</details>

---

## üéØ Problem 8: Next Order Preview (LEAD)
**Difficulty: Medium** | **Concept: LEAD function**

Show each order with the next order's date.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    c.name AS customer,
    o.order_date,
    o.amount,
    LEAD(o.order_date) OVER (
        PARTITION BY o.customer_id 
        ORDER BY o.order_date
    ) AS next_order_date,
    LEAD(o.order_date) OVER (
        PARTITION BY o.customer_id 
        ORDER BY o.order_date
    ) - o.order_date AS days_until_next
FROM orders o
JOIN customers c ON o.customer_id = c.id
ORDER BY c.name, o.order_date;
```
</details>

---

## üéØ Problem 9: Moving Average
**Difficulty: Hard** | **Concept: Window frame**

Calculate 3-order moving average per customer.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    c.name AS customer,
    o.order_date,
    o.amount,
    ROUND(AVG(o.amount) OVER (
        PARTITION BY o.customer_id 
        ORDER BY o.order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ), 2) AS moving_avg_3
FROM orders o
JOIN customers c ON o.customer_id = c.id
ORDER BY c.name, o.order_date;
```

**Window frame options:**
- `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW` - previous 2 + current
- `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING` - previous + current + next
- `ROWS UNBOUNDED PRECEDING` - all rows from start
</details>

---

## üéØ Problem 10: Percentile Rank
**Difficulty: Medium** | **Concept: PERCENT_RANK / NTILE**

Show salary percentile for each employee.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    name,
    salary,
    ROUND(PERCENT_RANK() OVER (ORDER BY salary) * 100, 1) AS percentile,
    NTILE(4) OVER (ORDER BY salary) AS quartile
FROM employees
ORDER BY salary DESC;
```

**Quartile interpretation:**
- 1 = Bottom 25%
- 2 = 25-50%
- 3 = 50-75%
- 4 = Top 25%
</details>

---

## üéØ Problem 11: First and Last Value
**Difficulty: Medium** | **Concept: FIRST_VALUE / LAST_VALUE**

Show each employee with their department's lowest and highest salary.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    d.name AS department,
    e.name AS employee,
    e.salary,
    FIRST_VALUE(e.salary) OVER (
        PARTITION BY e.department_id 
        ORDER BY e.salary
    ) AS min_salary,
    LAST_VALUE(e.salary) OVER (
        PARTITION BY e.department_id 
        ORDER BY e.salary
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS max_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
ORDER BY d.name, e.salary;
```

**Note:** LAST_VALUE needs explicit frame to see all rows.
</details>

---

## üéØ Problem 12: Salary Difference from Average
**Difficulty: Medium** | **Concept: Window aggregate**

Show each employee's salary difference from department average.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
SELECT 
    d.name AS department,
    e.name AS employee,
    e.salary,
    ROUND(AVG(e.salary) OVER (PARTITION BY e.department_id), 2) AS dept_avg,
    e.salary - ROUND(AVG(e.salary) OVER (PARTITION BY e.department_id), 2) AS diff_from_avg
FROM employees e
JOIN departments d ON e.department_id = d.id
ORDER BY d.name, e.salary DESC;
```
</details>

---

## üéØ Problem 13: Consecutive Days Detection
**Difficulty: Hard** | **Concept: LAG for gaps**

Find orders placed on consecutive days by same customer.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH order_gaps AS (
    SELECT 
        c.name AS customer,
        o.order_date,
        o.amount,
        LAG(o.order_date) OVER (
            PARTITION BY o.customer_id 
            ORDER BY o.order_date
        ) AS prev_date,
        o.order_date - LAG(o.order_date) OVER (
            PARTITION BY o.customer_id 
            ORDER BY o.order_date
        ) AS days_gap
    FROM orders o
    JOIN customers c ON o.customer_id = c.id
)
SELECT *
FROM order_gaps
WHERE days_gap = 1;
```
</details>

---

## üéØ Problem 14: Year-over-Year Growth
**Difficulty: Hard** | **Concept: LAG for comparison**

Calculate month-over-month order growth.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH monthly_totals AS (
    SELECT 
        TO_CHAR(order_date, 'YYYY-MM') AS month,
        SUM(amount) AS total
    FROM orders
    GROUP BY TO_CHAR(order_date, 'YYYY-MM')
)
SELECT 
    month,
    total,
    LAG(total) OVER (ORDER BY month) AS prev_month,
    ROUND(
        (total - LAG(total) OVER (ORDER BY month)) / 
        LAG(total) OVER (ORDER BY month) * 100, 
        2
    ) AS growth_pct
FROM monthly_totals
ORDER BY month;
```
</details>

---

## üéØ Problem 15: Top N per Group
**Difficulty: Hard** | **Concept: Practical application**

Find top 2 highest paid employees per department.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
WITH ranked AS (
    SELECT 
        e.name,
        e.salary,
        d.name AS department,
        DENSE_RANK() OVER (
            PARTITION BY e.department_id 
            ORDER BY e.salary DESC
        ) AS rn
    FROM employees e
    JOIN departments d ON e.department_id = d.id
)
SELECT department, name, salary, rn
FROM ranked
WHERE rn <= 2
ORDER BY department, rn;
```
</details>

---

## üìù Day 6 Interview Questions

1. **ROW_NUMBER vs RANK vs DENSE_RANK?**
   - ROW_NUMBER: Unique numbers, no ties (1,2,3,4)
   - RANK: Same for ties, skips numbers (1,2,2,4)
   - DENSE_RANK: Same for ties, no skip (1,2,2,3)

2. **What is a window frame?**
   - Defines which rows are included in calculation
   - ROWS vs RANGE
   - PRECEDING / FOLLOWING / CURRENT ROW

3. **LAG vs LEAD?**
   - LAG: Access previous row's value
   - LEAD: Access next row's value
   - Both take offset and default as optional params

4. **Can you use WHERE with window functions?**
   - No, window functions run after WHERE
   - Use a CTE or subquery to filter results

5. **ROWS vs RANGE in frame?**
   - ROWS: Physical row offsets
   - RANGE: Logical value ranges (based on ORDER BY)

---

## ‚úÖ Day 6 Checklist

- [ ] Completed all 15 problems
- [ ] Understand ROW_NUMBER vs RANK vs DENSE_RANK
- [ ] Can write running totals and moving averages
- [ ] Know how to use LAG/LEAD
- [ ] Understand window frames (ROWS BETWEEN...)
