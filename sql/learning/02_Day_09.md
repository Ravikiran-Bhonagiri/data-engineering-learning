# üóìÔ∏è Day 9: Transactions & Concurrency

## üìö Topics Covered
- ACID properties
- BEGIN/COMMIT/ROLLBACK
- Savepoints
- Isolation levels
- Deadlock handling

---

## üéØ Problem 1: Basic Transaction
**Difficulty: Easy** | **Concept: BEGIN/COMMIT**

Write a transaction that updates two employees' salaries atomically.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
BEGIN;

-- Give Sarah a raise
UPDATE employees SET salary = salary + 10000 WHERE name = 'Sarah Johnson';

-- Reduce Mike's salary (transfer)
UPDATE employees SET salary = salary - 5000 WHERE name = 'Mike Brown';

-- All good? Commit
COMMIT;

-- If something went wrong, use: ROLLBACK;
```
</details>

---

## üéØ Problem 2: Transaction with Error Check
**Difficulty: Medium** | **Concept: Validation**

Ensure balance doesn't go negative during transfer.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
DO $$
DECLARE
    source_balance DECIMAL;
    transfer_amount DECIMAL := 20000;
BEGIN
    -- Check source has enough
    SELECT salary INTO source_balance 
    FROM employees WHERE id = 3;
    
    IF source_balance < transfer_amount THEN
        RAISE EXCEPTION 'Insufficient funds: $% available, $% requested',
            source_balance, transfer_amount;
    END IF;
    
    -- Proceed with transfer
    UPDATE employees SET salary = salary - transfer_amount WHERE id = 3;
    UPDATE employees SET salary = salary + transfer_amount WHERE id = 4;
    
    RAISE NOTICE 'Transfer completed successfully';
END $$;
```
</details>

---

## üéØ Problem 3: Savepoint Usage
**Difficulty: Medium** | **Concept: Partial rollback**

Use savepoints for partial commits.

```sql
-- Write your solution here
```

<details>
<summary>üí° Click for Solution</summary>

```sql
BEGIN;

-- First update
UPDATE orders SET status = 'processing' WHERE id = 1;
SAVEPOINT after_first_update;

-- Second update (might fail)
UPDATE orders SET status = 'shipped' WHERE id = 2;

-- If second update has issues, rollback to savepoint
ROLLBACK TO SAVEPOINT after_first_update;

-- First update is still done
COMMIT;
```
</details>

---

## üéØ Problem 4: Isolation Level Demo
**Difficulty: Hard** | **Concept: READ COMMITTED vs SERIALIZABLE**

Demonstrate different isolation levels (concept explanation).

```sql
-- Session 1 and Session 2 commands
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- SESSION 1
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT salary FROM employees WHERE id = 1;  -- Returns 150000
-- Wait for Session 2 to commit
SELECT salary FROM employees WHERE id = 1;  -- Returns 160000 (sees change)
COMMIT;

-- SESSION 2 (run while Session 1 is between SELECTs)
BEGIN;
UPDATE employees SET salary = 160000 WHERE id = 1;
COMMIT;
```

**Isolation Levels:**
| Level | Dirty Read | Non-Repeatable | Phantom |
|-------|------------|----------------|---------|
| READ UNCOMMITTED | Yes | Yes | Yes |
| READ COMMITTED | No | Yes | Yes |
| REPEATABLE READ | No | No | Yes |
| SERIALIZABLE | No | No | No |
</details>

---

## üéØ Problem 5: Deadlock Understanding
**Difficulty: Hard** | **Concept: Deadlock scenario**

Understand how deadlocks happen.

```sql
-- Conceptual example
```

<details>
<summary>üí° Click for Solution</summary>

```sql
-- SESSION 1
BEGIN;
UPDATE employees SET salary = salary + 100 WHERE id = 1;
-- Wait...
UPDATE employees SET salary = salary + 100 WHERE id = 2;
-- DEADLOCK!

-- SESSION 2 (run after Session 1's first UPDATE)
BEGIN;
UPDATE employees SET salary = salary + 100 WHERE id = 2;
-- Now:
UPDATE employees SET salary = salary + 100 WHERE id = 1;
-- DEADLOCK! One session will be killed

-- Prevention: Always lock resources in the same order!
-- Example: Always update lower ID first
```
</details>

---

## üìù Day 9 Interview Questions

1. **Explain ACID properties**
   - Atomicity: All succeed or all fail
   - Consistency: Data valid after transaction
   - Isolation: Transactions don't see uncommitted changes
   - Durability: Committed data survives crashes

2. **What is a phantom read?**
   - New rows appear in repeated query
   - Prevented by SERIALIZABLE level

3. **How does the database handle deadlocks?**
   - Detects circular waits
   - Kills one transaction as victim
   - That transaction should retry

---

## ‚úÖ Day 9 Checklist

- [ ] Completed all 5 problems
- [ ] Understand ACID properties
- [ ] Can use BEGIN/COMMIT/ROLLBACK
- [ ] Know isolation levels
- [ ] Understand deadlock prevention
